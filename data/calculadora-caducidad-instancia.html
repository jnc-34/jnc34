<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Calculadora de Caducidad de la Instancia</title>
  <style>
    :root{font-family:system-ui,-apple-system,Segoe UI,Roboto,'Helvetica Neue',Arial;max-width:900px;margin:0 auto}
    body{padding:18px;color:#111}
    h1{font-size:1.4rem;margin-bottom:.2rem}
    label{display:block;margin-top:12px}
    input,select,button{font-size:1rem;padding:8px;margin-top:6px;border-radius:6px;border:1px solid #ddd}
    .row{display:flex;gap:10px;align-items:center}
    .result{margin-top:16px;padding:12px;border-radius:8px;background:#f7f7fb;border:1px solid #eee}
    .warning{background:#fff3cd;border:1px solid #ffeeba;padding:12px;border-radius:8px;margin-top:12px;white-space:pre-wrap}
    small{color:#555}
    footer{margin-top:20px;font-size:.85rem;color:#444}
    .muted{color:#666;font-size:.9rem}
  </style>
</head>
<body>
  <h1>Calculadora de Caducidad de la Instancia</h1>

  <div class="warning" id="advertencia"></div>

  <form id="form" onsubmit="return false;">
    <label>1) Seleccione el plazo del art. 310 CPCCN a computar:</label>
    <select id="tipoPlazo">
      <option value="6">6 meses (primera o única instancia), inc. 1°</option>
      <option value="3">3 meses (segunda o tercera instancia, juicio sumarísimo, ejecutivo, ejecuciones especiales e incidentes), inc. 2°</option>
      <option value="custom">De prescripción de la acción (inc. 3°) - indicar meses (máx 6)</option>
      <option value="1">1 mes (incidente de caducidad de instancia), inc. 4°</option>
    </select>

    <div id="customContainer" style="display:none">
      <label>Indique plazo en meses (1-6):</label>
      <input type="number" id="customMonths" min="1" max="6" value="6" />
    </div>

    <label>2) Indique fecha del último acto que impulsó el procedimiento:</label>
    <div class="row">
      <input id="dia" type="text" inputmode="numeric" maxlength="2" placeholder="DD" style="width:72px;" />
      <input id="mes" type="text" inputmode="numeric" maxlength="2" placeholder="MM" style="width:72px;" />
      <input id="anio" type="text" inputmode="numeric" maxlength="4" placeholder="AAAA" style="width:120px;" />
    </div>

    <div style="margin-top:12px">
      <button type="button" id="calcular">Calcular vencimiento</button>
      <button type="button" id="limpiar">Limpiar</button>
    </div>
  </form>

  <div class="result" id="resultado" style="display:none">
    <strong>Vencimiento:</strong>
    <div id="vencimientoText" style="margin-top:8px"></div>
    <small id="explicacion" class="muted"></small>
  </div>

  <footer>
    <p class="muted">Notas: Esta calculadora implementa la lógica solicitada (cómputo fecha a fecha; si el día final no existe en el mes de vencimiento se toma el último día; se excluyen exclusivamente las ferias judiciales: todo enero y 12 días corridos a partir del 3er lunes de julio). Revise siempre con criterio profesional.</p>
  </footer>

<script>
// ---------- Advertencia ----------
const advertenciaTexto = `A continuación se presenta una "Calculadora de Caducidad de la Instancia" cuyo código fuente fue generado mediante Inteligencia Artificial y puede contener errores. Es una herramienta complementaria y no sustituye el criterio profesional ni la consulta de la normativa vigente.

Consideraciones clave para el cómputo:
- Receso de verano: se excluye todo el mes de enero (1 al 31).
- Receso de invierno: se excluyen 12 días corridos a partir del tercer lunes de julio de cada año.
Las fechas del Receso Invernal son variables y definidas anualmente por la CSJN; verifíquelas.

Utilice esta calculadora bajo su propia responsabilidad y contrastando siempre el resultado.`;
document.getElementById('advertencia').innerText = advertenciaTexto;

// ---------- Helpers en UTC ----------
function utcDate(y,m,d){ return new Date(Date.UTC(y,m,d)); } // m:0-11
function daysInMonth(y,m){ return new Date(Date.UTC(y,m+1,0)).getUTCDate(); }
function addDaysUTC(d,n){ return new Date(Date.UTC(d.getUTCFullYear(), d.getUTCMonth(), d.getUTCDate() + n)); }
function formatDateUTC(d){ if(!(d instanceof Date) || isNaN(d)) return 'Invalid'; const dd=('0'+d.getUTCDate()).slice(-2); const mm=('0'+(d.getUTCMonth()+1)).slice(-2); return `${dd}/${mm}/${d.getUTCFullYear()}`; }

// suma meses fecha-a-fecha en UTC
function addMonthsDateToDateUTC(date, months){
  const y = date.getUTCFullYear(), m = date.getUTCMonth(), day = date.getUTCDate();
  const targetMonthIndex = m + months;
  const targetYear = y + Math.floor(targetMonthIndex / 12);
  const targetMonth = ((targetMonthIndex % 12) + 12) % 12;
  const dim = daysInMonth(targetYear, targetMonth);
  const resultDay = Math.min(day, dim);
  return utcDate(targetYear, targetMonth, resultDay);
}

function thirdMondayOfJulyUTC(year){
  const d = utcDate(year,6,1);
  const dow = d.getUTCDay();
  const firstMonday = 1 + ((8 - dow) % 7);
  const thirdMonday = firstMonday + 14;
  return utcDate(year,6,thirdMonday);
}

function buildExcludedPeriodsUTC(yearFrom, yearTo){
  const periods = [];
  for(let y = yearFrom - 1; y <= yearTo + 1; y++){
    periods.push({ start: utcDate(y,0,1), end: utcDate(y,0,31) }); // enero entero
    const tm = thirdMondayOfJulyUTC(y);
    periods.push({ start: tm, end: addDaysUTC(tm, 11) }); // 12 días inclusivos
  }
  return periods;
}

function overlapDaysInclusiveUTC(a,b,c,d){
  if(a.getTime() > b.getTime() || c.getTime() > d.getTime()) return 0;
  const start = a.getTime() > c.getTime() ? a : c;
  const end = b.getTime() < d.getTime() ? b : d;
  if(start.getTime() > end.getTime()) return 0;
  const msPerDay = 24*60*60*1000;
  return Math.floor((end.getTime() - start.getTime()) / msPerDay) + 1;
}

function findContainingPeriodUTC(date, periods){
  for(const p of periods) if(date.getTime() >= p.start.getTime() && date.getTime() <= p.end.getTime()) return p;
  return null;
}

// ---------- Algoritmo principal (eficiente y robusto) ----------
function computeExpirationUTC(startDateUTC, months){
  // startDateUTC must be a Date at UTC midnight
  let candidate = addMonthsDateToDateUTC(startDateUTC, months);
  let excluded = buildExcludedPeriodsUTC(startDateUTC.getUTCFullYear(), candidate.getUTCFullYear() + 1);

  const maxIter = 50;
  let iter = 0;
  while(iter < maxIter){
    iter++;
    const intervalStart = addDaysUTC(startDateUTC, 1); // se cuenta desde el día siguiente
    const intervalEnd = candidate;
    // 1) sumar días excluidos en (start, candidate]
    let totalExcluded = 0;
    for(const p of excluded){
      totalExcluded += overlapDaysInclusiveUTC(intervalStart, intervalEnd, p.start, p.end);
    }

    if(totalExcluded > 0){
      candidate = addDaysUTC(candidate, totalExcluded);
      excluded = buildExcludedPeriodsUTC(startDateUTC.getUTCFullYear(), candidate.getUTCFullYear() + 1);
      continue; // re-evaluar
    }

    // 2) si queda dentro de una feria, mover al día siguiente al final de esa feria
    const inside = findContainingPeriodUTC(candidate, excluded);
    if(inside){
      candidate = addDaysUTC(inside.end, 1);
      excluded = buildExcludedPeriodsUTC(startDateUTC.getUTCFullYear(), candidate.getUTCFullYear() + 1);
      continue;
    }

    // estable -> fin
    break;
  }

  return candidate;
}

// ---------- UI wiring ----------
const tipoPlazo = document.getElementById('tipoPlazo');
const customContainer = document.getElementById('customContainer');
const customMonths = document.getElementById('customMonths');
const diaInput = document.getElementById('dia');
const mesInput = document.getElementById('mes');
const anioInput = document.getElementById('anio');
const resultadoDiv = document.getElementById('resultado');
const vencimientoText = document.getElementById('vencimientoText');
const explicacion = document.getElementById('explicacion');

tipoPlazo.addEventListener('change', ()=>{ customContainer.style.display = (tipoPlazo.value === 'custom') ? 'block' : 'none'; });

function onlyDigits(e){ const allowed=['Backspace','ArrowLeft','ArrowRight','Tab','Delete']; if(allowed.includes(e.key)) return; if(!/^[0-9]$/.test(e.key)) e.preventDefault(); }
[diaInput, mesInput, anioInput].forEach(i => i.addEventListener('keydown', onlyDigits));

function parseUserDateToUTC(){
  const d = diaInput.value.trim(), m = mesInput.value.trim(), y = anioInput.value.trim();
  if(!/^\d{1,2}$/.test(d) || !/^\d{1,2}$/.test(m) || !/^\d{4}$/.test(y)) return null;
  const day = parseInt(d,10), month = parseInt(m,10), year = parseInt(y,10);
  if(month < 1 || month > 12) return null;
  const dim = daysInMonth(year, month - 1);
  if(day < 1 || day > dim) return null;
  return utcDate(year, month - 1, day);
}

function showError(msg){ alert(msg); }

document.getElementById('calcular').addEventListener('click', ()=>{
  const startUTC = parseUserDateToUTC();
  if(!startUTC){ showError('Indique una fecha válida en formato DD MM AAAA'); return; }
  let months = 0;
  if(tipoPlazo.value === 'custom'){
    months = parseInt(customMonths.value, 10);
    if(isNaN(months) || months < 1 || months > 6){ showError('El plazo de prescripción (inc.3°) debe estar entre 1 y 6 meses'); return; }
  } else months = parseInt(tipoPlazo.value, 10);

  const venc = computeExpirationUTC(startUTC, months);
  if(!venc){ showError('Error al calcular la fecha.'); return; }

  resultadoDiv.style.display = 'block';
  vencimientoText.innerText = formatDateUTC(venc) + ' — vence a las 24:00 hrs del día indicado';
  explicacion.innerText = `Cómputo iniciado el ${formatDateUTC(startUTC)}. Plazo nominal: ${months} mes(es). Se aplicaron exclusiones de ferias (enero y receso de invierno).`;
});

document.getElementById('limpiar').addEventListener('click', ()=>{
  diaInput.value = ''; mesInput.value = ''; anioInput.value = ''; tipoPlazo.value = '6'; customContainer.style.display = 'none'; customMonths.value = '6'; resultadoDiv.style.display = 'none';
});
</script>
<script>
/* SCRIPT DE DIAGNÓSTICO — temporal. 
   Pega esto en tu HTML (reemplazando el bloque <script> existente o al final del body), 
   abre la consola y ejecuta una prueba. Luego pega los logs aquí. */

(function(){
  console.log('--- DEBUG: inicio diagnóstico calculadora ---');

  // Helpers UTC (idénticos a la versión robusta)
  function utcDate(y,m,d){ return new Date(Date.UTC(y,m,d)); }
  function daysInMonth(y,m){ return new Date(Date.UTC(y,m+1,0)).getUTCDate(); }
  function addDaysUTC(d,n){ const y=d.getUTCFullYear(), m=d.getUTCMonth(), day=d.getUTCDate(); return utcDate(y,m, day + n); }
  function formatUTC(d){ if(!d || isNaN(d)) return 'InvalidDate'; return ('0'+d.getUTCDate()).slice(-2)+'/'+('0'+(d.getUTCMonth()+1)).slice(-2)+'/'+d.getUTCFullYear(); }

  function addMonthsDateToDateUTC(date, months){
    const y = date.getUTCFullYear(), m = date.getUTCMonth(), day = date.getUTCDate();
    const targetMonthIndex = m + months;
    const targetYear = y + Math.floor(targetMonthIndex / 12);
    const targetMonth = ((targetMonthIndex % 12) + 12) % 12;
    const dim = daysInMonth(targetYear, targetMonth);
    const resultDay = Math.min(day, dim);
    return utcDate(targetYear, targetMonth, resultDay);
  }

  function thirdMondayOfJulyUTC(year){
    const d = utcDate(year,6,1);
    const dow = d.getUTCDay();
    const firstMonday = 1 + ((8 - dow) % 7);
    const thirdMonday = firstMonday + 14;
    return utcDate(year,6,thirdMonday);
  }

  function buildExcludedUTC(yearFrom, yearTo){
    const arr = [];
    for(let y=yearFrom-1; y<=yearTo+1; y++){
      arr.push({start: utcDate(y,0,1), end: utcDate(y,0,31)}); // enero
      const tm = thirdMondayOfJulyUTC(y);
      arr.push({start: tm, end: addDaysUTC(tm,11)}); // 12 días
    }
    return arr;
  }

  function overlapDaysInclusive(a,b,c,d){
    if(a.getTime() > b.getTime() || c.getTime() > d.getTime()) return 0;
    const start = a.getTime() > c.getTime() ? a : c;
    const end = b.getTime() < d.getTime() ? b : d;
    if(start.getTime() > end.getTime()) return 0;
    const msPerDay = 24*60*60*1000;
    return Math.floor((end.getTime() - start.getTime())/msPerDay) + 1;
  }

  function findPeriod(date, arr){
    for(const p of arr) if(date.getTime() >= p.start.getTime() && date.getTime() <= p.end.getTime()) return p;
    return null;
  }

  // versión diagnóstica del algoritmo (igual a la robusta, con logs)
  function computeExpirationDiag(startUTC, months){
    console.log('DEBUG: startUTC', formatUTC(startUTC), 'months', months);
    let candidate = addMonthsDateToDateUTC(startUTC, months);
    console.log('DEBUG: candidate inicial (fecha-a-fecha)', formatUTC(candidate));
    let excluded = buildExcludedUTC(startUTC.getUTCFullYear(), candidate.getUTCFullYear()+1);
    console.log('DEBUG: excluded periods (primeros 6):', excluded.slice(0,6).map(p=>({start:formatUTC(p.start), end:formatUTC(p.end)})));

    const max = 100;
    let iter = 0;
    while(iter < max){
      iter++;
      const intervalStart = addDaysUTC(startUTC, 1);
      const intervalEnd = candidate;
      // sumar exclusiones
      let totalExcluded = 0;
      for(const p of excluded){
        const ov = overlapDaysInclusive(intervalStart, intervalEnd, p.start, p.end);
        if(ov>0) console.log(`DEBUG iter ${iter}: overlap with period ${formatUTC(p.start)} - ${formatUTC(p.end)} => ${ov} días`);
        totalExcluded += ov;
      }
      console.log(`DEBUG iter ${iter}: totalExcluded in (start+1 .. candidate) = ${totalExcluded}`);
      if(totalExcluded > 0){
        candidate = addDaysUTC(candidate, totalExcluded);
        console.log(`DEBUG iter ${iter}: candidate after adding excluded = ${formatUTC(candidate)}`);
        excluded = buildExcludedUTC(startUTC.getUTCFullYear(), candidate.getUTCFullYear()+1);
        continue;
      }
      const inside = findPeriod(candidate, excluded);
      if(inside){
        console.log(`DEBUG iter ${iter}: candidate ${formatUTC(candidate)} is inside period ${formatUTC(inside.start)} - ${formatUTC(inside.end)} -> moving to day after end`);
        candidate = addDaysUTC(inside.end, 1);
        console.log(`DEBUG iter ${iter}: candidate moved to ${formatUTC(candidate)}`);
        excluded = buildExcludedUTC(startUTC.getUTCFullYear(), candidate.getUTCFullYear()+1);
        continue;
      }
      console.log('DEBUG: estabilizado en iter', iter);
      break;
    }
    if(iter>=max) console.warn('DEBUG: max iter alcanzado', iter);
    console.log('DEBUG: candidate final', formatUTC(candidate));
    return candidate;
  }

  // función que lee los campos existentes (intenta ser compatible con variantes)
  function readInputs(){
    const dEl = document.getElementById('dia');
    const mEl = document.getElementById('mes');
    const yEl = document.getElementById('anio');
    const fallbackDateInput = document.getElementById('fecha'); // en caso de que exista la versión vieja
    let d = dEl && dEl.value ? dEl.value.trim() : null;
    let m = mEl && mEl.value ? mEl.value.trim() : null;
    let y = yEl && yEl.value ? yEl.value.trim() : null;
    if((!d || !m || !y) && fallbackDateInput && fallbackDateInput.value){
      console.log('DEBUG: usando input tipo=date fallback (fecha)');
      const f = fallbackDateInput.value; // formato yyyy-mm-dd
      const parts = f.split('-');
      if(parts.length===3){ y = parts[0]; m = parts[1]; d = parts[2]; }
    }
    return {d,m,y};
  }

  // handler que puedes llamar desde la consola: runDebug()
  window.runCalcDebug = function(){
    console.log('--- runCalcDebug() invoked ---');
    const inputs = readInputs();
    console.log('DEBUG: raw inputs', inputs);
    const reD = /^\d{1,2}$/, reM = /^\d{1,2}$/, reY = /^\d{4}$/;
    if(!reD.test(inputs.d) || !reM.test(inputs.m) || !reY.test(inputs.y)){ console.error('DEBUG: entrada inválida'); return; }
    const day = parseInt(inputs.d,10), month = parseInt(inputs.m,10), year = parseInt(inputs.y,10);
    if(month<1||month>12){ console.error('DEBUG: mes inválido'); return; }
    const dim = daysInMonth(year, month-1);
    if(day<1||day>dim){ console.error('DEBUG: día inválido para ese mes'); return; }
    const startUTC = utcDate(year, month-1, day);
    // leer months seleccionado (compatible con select id tipoPlazo + custom)
    const tipo = document.getElementById('tipoPlazo') ? document.getElementById('tipoPlazo').value : null;
    let months = tipo && tipo !== 'custom' ? parseInt(tipo,10) : (document.getElementById('customMonths') ? parseInt(document.getElementById('customMonths').value,10) : null);
    console.log('DEBUG: meses a computar =', months);
    if(isNaN(months) || months < 1){ console.error('DEBUG: meses inválidos'); return; }
    const final = computeExpirationDiag(startUTC, months);
    console.log('--- RESULTADO FINAL ---', formatUTC(final));
    // además, muestra en pantalla (si existe el contenedor)
    const outEl = document.getElementById('vencimientoText');
    const resDiv = document.getElementById('resultado');
    if(outEl && resDiv){ outEl.innerText = formatUTC(final) + ' — vence a las 24:00 hrs del día indicado'; resDiv.style.display='block'; }
  };

  console.log('DEBUG: Instrucciones -> escribe runCalcDebug() en la consola tras cargar la página y pulsar calcular (o directamente tras completar campos).');
  console.log('--- DEBUG: fin carga script ---');
})();
</script>
</body>
</html>
